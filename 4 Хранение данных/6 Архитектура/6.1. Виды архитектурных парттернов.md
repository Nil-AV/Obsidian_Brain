

[[6.1.1. Монолитная архитектура]]

[[6.1.2. Распределенная архитектура]]






### Управляемая событиями архитектура

**Управляемая событиями архитектура (EDA)** - это архитектурный стиль, в котором компоненты системы взаимодействуют друг с другом асинхронно, через передачу событий. Вместо прямого вызова методов, компоненты публикуют и подписываются на события.

**Ключевые принципы EDA:**

- **Асинхронность**: Компоненты взаимодействуют без необходимости синхронного ожидания ответа.
- **Децентрализация**: Отсутствует центральный управляющий компонент, который координирует все операции.
- **Свободная связь**: Компоненты не имеют прямой зависимости друг от друга, взаимодействуя через события.
- **События как источник информации**: События служат единым языком для обмена данными и уведомлений между компонентами.

**Преимущества EDA:**

- **Масштабируемость**: Легко добавлять новые компоненты и масштабировать систему, не затрагивая существующие.
- **Устойчивость**: Система становится более устойчивой к отказам, так как компоненты не зависят друг от друга.
- **Гибкость**: Возможность быстро реагировать на изменения требований, добавляя или модифицируя компоненты без изменения всей системы.
- **Независимость**: Компоненты могут быть разработаны и развернуты независимо друг от друга.
- **Лучшее понимание потока данных**: События предоставляют четкую картину о том, что происходит в системе.

**Архитектурные компоненты EDA:**

- **Источник событий**: Компонент, который генерирует события.
- **Канал событий**: Механизм, обеспечивающий передачу событий от источника к получателям.
- **Обработчик событий**: Компонент, который реагирует на события и выполняет определенные действия.

**Реализации EDA:**

- **Мессенджер**: Используется для публикации и подписки на события (например, RabbitMQ, Kafka).
- **Потоковая обработка**: Обработка событий в реальном времени (например, Apache Flink, Apache Spark Streaming).
- **Реактивное программирование**: Написание кода, реагирующего на изменения данных (например, RxJava, ReactiveX).

**Примеры использования EDA:**

- **Обработка заказов**: Создание заказа, изменение статуса заказа, отмена заказа.
- **Аналитика**: Сбор данных, анализ данных, создание отчетов.
- **Микросервисы**: Взаимодействие между микросервисами.

**Недостатки EDA:**

- **Сложность**: Сложнее реализовать и поддерживать, чем традиционные архитектуры.
- **Отладка**: Сложно отлаживать систему из-за асинхронности и децентрализованности.
- **Согласованность**: Необходимо обеспечивать согласованность данных между компонентами.
**EDA - это мощный инструмент для создания масштабируемых, устойчивых и гибких систем. Она подходит для сложных приложений, где требуется обработка большого количества данных в реальном времени.**
### Представление — контроллер

**MVC (Model-View-Controller)** - это архитектурный шаблон, который разделяет приложение на три основных компонента:

**1. Модель (Model)**:

- Отвечает за хранение и управление данными приложения.
- Не зависит от представления и контроллера.
- Представляет бизнес-логику приложения.
- Предоставляет доступ к данным для контроллера и представления.
- Может уведомлять контроллер о изменениях данных.

**2. Представление (View)**:

- Отвечает за отображение данных пользователю.
- Получает данные от контроллера.
- Не содержит бизнес-логику.
- Обновляется, когда контроллер уведомляет о изменениях в модели.

**3. Контроллер (Controller)**:

- Обеспечивает взаимодействие между моделью и представлением.
- Получает запросы от пользователя (например, нажатия на кнопку).
- Обновляет модель в соответствии с запросом пользователя.
- Выбирает подходящее представление для отображения данных.
- Уведомляет представление о изменениях в модели.

**Преимущества MVC:**

- **Разделение ответственности**: Каждая часть приложения отвечает за свою функцию.
- **Тестируемость**: Каждая часть приложения может быть протестирована независимо.
- **Повторное использование**: Модули могут быть повторно использованы в других проектах.
- **Гибкость**: Легко изменять представление или контроллер без изменения модели.
- **Масштабируемость**: Легко добавлять новые функции, не затрагивая существующие.

**Пример использования MVC:**

- **Веб-приложение**: Модель хранит данные о пользователях и товарах, контроллер обрабатывает запросы от пользователей, а представление отображает информацию о товарах.

**Реализации MVC:**

- **Ruby on Rails**: Веб-фреймворк, использующий MVC.
- **ASP.NET MVC**: Фреймворк для создания веб-приложений.
- **Spring MVC**: Фреймворк для создания веб-приложений на Java.

**Недостатки MVC:**

- **Сложность**: Может быть сложнее для небольших проектов.
- **Дополнительный код**: Требуется больше кода для реализации, чем в других архитектурах.
- **Не всегда оптимально**: Не подходит для всех типов приложений, например, для одностраничных приложений.

**MVC - это проверенный временем архитектурный шаблон, который хорошо подходит для создания веб-приложений и других сложных систем. Он позволяет обеспечить разделение ответственности, улучшить тестируемость и упростить разработку.**

### Клиент — сервер

**Архитектура “Клиент-сервер”** - это архитектурный стиль, где приложение разделено на два основных компонента: **клиент** и **сервер**.

**Клиент**:

- Представляет собой программу, которая запрашивает ресурсы или услуги у сервера.
- Обычно работает на устройствах пользователей, таких как компьютеры, смартфоны, планшеты.
- Отправляет запросы к серверу и получает ответы.
- Отображает информацию, предоставленную сервером, пользователю.

**Сервер**:

- Представляет собой программу, предоставляющую ресурсы или услуги клиентам.
- Обычно работает на мощных серверах или в облачных средах.
- Хранит данные, обрабатывает запросы клиентов и отправляет ответы.
- Обеспечивает доступ к ресурсам для клиентов.

**Как работает архитектура “Клиент-сервер”:**

1. **Клиент отправляет запрос к серверу:** Например, пользователь вводит адрес сайта в браузере, и браузер отправляет запрос к серверу сайта.
2. **Сервер обрабатывает запрос:** Сервер анализирует запрос и выполняет соответствующие операции, например, извлекает данные из базы данных.
3. **Сервер отправляет ответ клиенту:** Ответ может содержать информацию, файлы, или другие данные, запрошенные клиентом.
4. **Клиент получает ответ:** Клиент получает ответ от сервера и отображает его пользователю.

**Примеры архитектуры “Клиент-сервер”:**

- **Веб-сайты:** Браузер (клиент) отправляет запросы к веб-серверу, который обрабатывает их и отправляет HTML-код, изображения и другие файлы.
- **Электронная почта:** Почтовый клиент (клиент) отправляет сообщения на почтовый сервер, который хранит их и доставляет их получателям.
- **Онлайн-игры:** Игровой клиент (клиент) взаимодействует с игровым сервером, который обрабатывает игровые действия и предоставляет информацию о состоянии игры.
- **Базы данных:** Приложения (клиенты) подключаются к серверу баз данных, чтобы получить доступ к данным.

**Преимущества архитектуры “Клиент-сервер”:**

- **Централизованное управление:** Все данные и ресурсы хранятся на сервере, что облегчает управление и обновление.
- **Повышенная безопасность:** Сервер может обеспечить более строгие меры безопасности, чем отдельные клиентские устройства.
- **Масштабируемость:** Сервер может обслуживать множество клиентов одновременно.
- **Экономия ресурсов:** Клиенты могут использовать менее мощные устройства, так как основная обработка происходит на сервере.

**Недостатки архитектуры “Клиент-сервер”:**

- **Зависимость от сервера:** Клиент зависит от работоспособности сервера.
- **Проблемы с производительностью:** При большом количестве клиентов может возникнуть перегрузка сервера.
- **Сложность развертывания:** Требуется специализированное оборудование и программное обеспечение для настройки сервера.

**Архитектура “Клиент-сервер” является широко распространенным и эффективным архитектурным стилем, который применяется в различных приложениях. Она позволяет централизовать данные, повысить безопасность и масштабируемость, но требует внимания к производительности и зависимости от сервера.**

### Каналы и фильтры

Архитектура “Каналы и фильтры” (Pipes and Filters) - это архитектурный шаблон, где обработка данных происходит поэтапно, проходя через серию независимых компонентов, называемых “каналами” и “фильтрами”.

**Каналы (Pipes):**

- Отвечают за передачу данных между фильтрами.
- Действуют как “трубопроводы”, по которым данные перемещаются от одного фильтра к другому.
- Не обрабатывают данные, а только передают их.

**Фильтры (Filters):**

- Выполняют определенную операцию над данными.
- Независимы друг от друга, то есть каждый фильтр работает со своей частью данных.
- Могут быть соединены в цепочки, чтобы выполнить более сложную обработку.

**Как работает архитектура “Каналы и фильтры”:**

1. Данные вводятся в систему через входной канал.
2. Данные проходят через серию фильтров, каждый из которых выполняет свою задачу.
3. Фильтры могут изменять данные, добавлять новые данные или отбрасывать ненужные данные.
4. После обработки данных выводятся через выходной канал.

**Преимущества архитектуры “Каналы и фильтры”:**

- **Модульность:** Каждый фильтр независим и может быть легко заменен или модифицирован без влияния на другие фильтры.
- **Повторное использование:** Фильтры могут быть повторно использованы в других приложениях.
- **Масштабируемость:** Система может быть легко масштабирована путем добавления новых фильтров.
- **Параллелизм:** Фильтры могут выполняться параллельно, что ускоряет обработку данных.
- **Простая отладка:** Проблемы можно легко изолировать и устранять в отдельном фильтре.

**Примеры использования архитектуры “Каналы и фильтры”:**

- **Обработка текстовых файлов:** Фильтры могут быть использованы для очистки текста, перевода, форматирования и т. д.
- **Потоковая обработка данных:** Фильтры могут использоваться для фильтрации, агрегирования и преобразования данных в реальном времени.
- **Обработка сигналов:** Фильтры могут использоваться для обработки аудио, видео и других сигналов.

**Недостатки архитектуры “Каналы и фильтры”:**

- **Сложность управления:** При большом количестве фильтров управление системой может стать сложным.
- **Проблемы с производительностью:** Если данные передаются через множество фильтров, обработка может быть медленной.
- **Неподходящая для сложных зависимостей:** Архитектура не подходит для задач, где фильтры имеют сложные зависимости друг от друга.

**Архитектура “Каналы и фильтры” - это гибкий и модульный подход к обработке данных, который хорошо подходит для задач, где требуется поэтапная обработка данных. Она позволяет легко создавать сложные системы, которые легко масштабируются и модифицируются.**

### Многоуровневая (n-tier architecture)

Многоярусная архитектура - это архитектурный стиль, где приложение разделяется на несколько логических слоев (ярусов), каждый из которых отвечает за определенные функции. Эти слои взаимодействуют друг с другом, чтобы обеспечить функционирование приложения.

**Основные ярусы многоярусной архитектуры:**

- **Представление (Presentation Tier):** Ответственен за взаимодействие с пользователем. Обычно включает в себя графический интерфейс (GUI) приложения.
- **Логический ярус (Business Logic Tier):** Включает в себя бизнес-логику приложения. Отвечает за обработку данных, принятие решений и выполнение операций с данными.
- **Ярус данных (Data Tier):** Включает в себя хранилище данных, такое как базы данных, файлы и другие источники данных. Ответственен за сохранение и извлечение данных.

**Дополнительные ярусы:**

В зависимости от сложности приложения могут быть добавлены дополнительные ярусы, например:

- **Ярус безопасности:** Отвечает за аутентификацию и авторизацию пользователей.
- **Ярус интеграции:** Обеспечивает связь с другими системами.
- **Ярус сервисов:** Предоставляет сервисы для других ярусов.

**Преимущества многоярусной архитектуры:**

- **Разделение ответственности:** Каждый ярус отвечает за свою функцию, что делает систему более модульной и управляемой.
- **Масштабируемость:** Отдельные ярусы можно масштабировать независимо друг от друга.
- **Гибкость:** Изменения в одном ярусе не влияют на другие ярусы.
- **Повторное использование:** Ярусы могут быть повторно использованы в других приложениях.

**Недостатки многоярусной архитектуры:**

- **Сложность:** Сложнее разработать и отладить по сравнению с одноярусными приложениями.
- **Сетевые задержки:** Взаимодействие между ярусами может вызывать сетевые задержки.
- **Управление зависимостями:** Сложно управлять зависимостями между ярусами.

**Примеры многоярусной архитектуры:**

- **Веб-приложение:** Представление - веб-браузер, логический ярус - сервер приложений, ярус данных - база данных.
- **Мобильное приложение:** Представление - мобильное устройство, логический ярус - облачный сервер, ярус данных - база данных.
- **Корпоративная система:** Представление - клиентские приложения, логический ярус - сервер приложений, ярус данных - база данных, ярус безопасности - сервер аутентификации.

**Многоярусная архитектура - это эффективный подход для разработки сложных систем. Она позволяет разделить приложение на модули, повысить масштабируемость, гибкость и повторное использование. Однако, необходимо учитывать сложность разработки и управления многоярусными системами.**
### Многоуровневая