# Apache Kafka

Apache Kafka - это платформа для потоковой обработки данных с открытым исходным кодом, которая позволяет создавать высокопроизводительные, масштабируемые и отказоустойчивые системы для передачи и обработки событий в реальном времени.



**Основные понятия:**

- **Брокер (Broker):** Сервер, который хранит и обрабатывает сообщения. В кластере Kafka может быть несколько брокеров, которые работают вместе, обеспечивая отказоустойчивость и масштабируемость.
- **Тема (Topic):** Категория или тип сообщения, который передается по кафковской системе. Например, “пользовательские события”, “заказы”, “сенсорные данные”.
- **Сообщение (Message):** Фактическая единица данных, которая передается в Kafka. Сообщение содержит полезную нагрузку (данные) и метаданные, такие как время отправки, ключ и т.д.
- **Продюсер (Producer):** Приложение, которое отправляет сообщения в Kafka.
- **Консьюмер (Consumer):** Приложение, которое получает и обрабатывает сообщения из Kafka.
- **Разделы (Partitions):** Тема разделяется на секции (разделы) для распределения данных и повышения параллелизма при работе с сообщениями.
- **Офсет (Offset):** Уникальный номер, который идентифицирует конкретное сообщение в определенном разделе.
- **Группа потребителей (Consumer Group):** Группа потребителей, которые совместно потребляют сообщения из определенной темы.
- **Зоокепер (ZooKeeper):** Сервис, который используется для управления кластером Kafka. Он хранит метаданные о брокерах, темах и группах потребителей.

## **Идемпотентность** 
- это свойство операции, при котором ее многократное выполнение дает такой же результат, как и однократное. В контексте Kafka, это означает, что если сообщение было успешно отправлено, то его повторная отправка не приведет к дублированию данных в теме.

**Как работает идемпотентность в Kafka:**

1. **Идентификатор производителя (Producer ID):** Kafka присваивает уникальный идентификатор каждому производителю.
2. **Счетчик последовательности:** Kafka хранит счетчик для каждого производителя. Этот счетчик увеличивается с каждой отправкой сообщения.
3. **Проверка и отслеживание:** Kafka проверяет ID производителя и счетчик последовательности для каждого отправленного сообщения.
4. **Предотвращение дублирования:** Если сообщение с одинаковым ID производителя и счетчиком последовательности уже было успешно отправлено, Kafka не будет сохранять его повторно.

**Дополнительные моменты:**

- **Идемпотентность не гарантирует строгое однократное выполнение (exactly-once semantics).** Если производитель отправит сообщение, а Kafka подтвердит получение, но сообщение не будет сохранено из-за сбоя, то повторение сообщения произойдет.
- **Идемпотентность работает на уровне отдельного производителя.** Если два производителя отправляют одно и то же сообщение, то Kafka не сможет предотвратить дублирование.
- **Идемпотентность включена по умолчанию в Kafka начиная с версии 0.11.**

**Пример:**

Представьте, что вы отправляете транзакцию по банковскому счету.

- **Без идемпотентности:** Если сообщение о транзакции потеряется, и вы отправите его повторно, то на счету может быть двойная транзакция.
- **С идемпотентностью:** Kafka гарантирует, что повторная отправка сообщения не вызовет дублирование.

**Преимущества идемпотентности:**

- **Упрощает обработку ошибок:** Повторная отправка сообщений после сбоев становится безопасной.
- **Улучшает надежность:** Снижает риск потери данных из-за дублирования.
- **Повышает производительность:** Снижает нагрузку на систему за счет фильтрации дублирующих сообщений.
## Partitions


Разделы (Partitions) - это ключевой элемент архитектуры Apache Kafka, который позволяет разбить тему на логические секции для повышения производительности, масштабируемости и отказоустойчивости.

**Как работают разделы:**

- **Разбиение данных:** Каждая тема делится на несколько разделов. Сообщения, отправленные в определенную тему, распределяются по разделам на основе ключа сообщения (если он задан) или по алгоритму Round Robin (по кругу) в случае его отсутствия.
- **Независимое хранение:** Каждый раздел хранится на отдельном брокере в кластере Kafka. Это означает, что данные в каждом разделе доступны независимо от других разделов.
- **Параллелизм:** Разделы позволяют производителям и потребителям работать параллельно. Несколько производителей могут отправлять сообщения в один раздел, а несколько потребителей могут одновременно читать из разных разделов одной и той же темы.

**Зачем нужны разделы:**

- **Повышение производительности:** Разделы позволяют Kafka распределять нагрузку по нескольким брокерам, что увеличивает пропускную способность и скорость обработки сообщений.
- **Масштабируемость:** Разделы позволяют легко добавлять новые брокеры в кластер Kafka, без изменения структуры темы или перенастройки приложений.
- **Отказоустойчивость:** Если брокер с данным разделом выходит из строя, то сообщения в нем остаются доступными на других брокерах, которые хранят реплики этого раздела.
- **Управление данными:** Разделы позволяют управлять доступом к данным на уровне раздела. Например, можно настроить разделы для разных групп потребителей, чтобы обеспечить изоляцию данных.

**Примеры использования:**

- **Логгирование событий:** Если у вас есть много серверов, которые отправляют логи, можно использовать разделы для разделения логов от разных серверов на отдельные разделы, чтобы упростить обработку и анализ данных.
- **Транзакции:** Если вы используете Kafka для обработки транзакций, то разделы могут быть использованы для создания транзакционных тем, где все сообщения в одном разделе обрабатываются в одном атомарном блоке.
- **Потоковая аналитика:** Если вы используете Kafka для аналитики данных в реальном времени, то разделы могут быть использованы для разделения данных на отдельные потоки для параллельной обработки.

**Выбор количества разделов:**

Количество разделов в теме - это важный параметр, который влияет на производительность и масштабируемость. Количество разделов должно быть оптимальным для конкретной задачи и конфигурации кластера Kafka.

**Рекомендации:**

- Количество разделов должно быть больше, чем количество брокеров в кластере, чтобы обеспечить параллелизм.
- Количество разделов должно быть кратным количеству ядер процессора на каждом брокере, чтобы оптимизировать производительность.
- Количество разделов должно быть достаточным для обеспечения достаточной отказоустойчивости и масштабируемости.

**Основные преимущества использования Kafka:**

- **Высокая производительность:** Kafka может обрабатывать миллионы сообщений в секунду.
- **Масштабируемость:** Kafka легко масштабируется за счет добавления новых брокеров.
- **Отказоустойчивость:** Kafka обеспечивает дублирование данных и отказоустойчивость благодаря репликациям сообщений.
- **Потоковая обработка данных:** Kafka позволяет обрабатывать данные в реальном времени, не дожидаясь их сбора.
- **Разные варианты использования:** Kafka может использоваться для широкого спектра задач, от логгинга и мониторинга до обработки транзакций и потоковой аналитики.

**Примеры использования:**

- **Логгирование:** Запись событий, ошибок и аудита в реальном времени.
- **Мониторинг:** Сбор и анализ данных с датчиков, сервисов и систем.
- **Обработка транзакций:** Обеспечение доставки сообщений в системах онлайн-платежей, бронирования и т.д.
- **Потоковая аналитика:** Анализ данных в реальном времени для выявления тенденций и принятия решений.
- **Системы обмена сообщениями:** Создание децентрализованных систем обмена сообщениями, где приложения могут общаться друг с другом асинхронно.


## Офсет (Offset)
- это уникальный идентификатор, который используется для отслеживания позиции каждого сообщения в определенном разделе темы Kafka. Представьте себе раздел как ленту, где каждое сообщение имеет свой порядковый номер, который и называется офсетом.

**Как работает офсет:**

- **Уникальная идентификация:** Каждый офсет уникален в пределах конкретного раздела. Это позволяет однозначно определять каждое сообщение.
- **Порядковый номер:** Офсеты присваиваются сообщениям в порядке их поступления в раздел. Первое сообщение получает офсет 0, второе - 1, и так далее.
- **Управление позицией:** Потребители используют офсеты, чтобы отслеживать, какие сообщения они уже обработали и какие ещё нужно обработать.
- **Перемещение по ленте:** Офсеты позволяют потребителям “перематывать” ленту сообщений:
    - **Переход к определенному офсету:** Потребитель может получить доступ к определенному сообщению, указав его офсет.
    - **Переход к последнему офсету:** Потребитель может начать обработку с последнего сообщения, запросив офсет, равный количеству сообщений в разделе.

**Зачем нужны офсеты:**

- **Гарантия доставки:** Офсеты гарантируют, что каждое сообщение в разделе будет обработано ровно один раз.
- **Переработка сообщений:** Офсеты позволяют потребителям перезапускать обработку сообщений с определенного офсета, если в процессе произошла ошибка.
- **Сохранение состояния:** Офсеты могут использоваться для сохранения состояния потребителя. Например, потребитель может запомнить офсет последнего обработанного сообщения и возобновить обработку с этого места при перезапуске.
- **Управление данными:** Офсеты позволяют управлять доступом к данным в разделе на уровне отдельных сообщений.

**Примеры использования:**

- **Обработка потока событий:** Если у вас есть поток событий, то вы можете использовать офсеты для отслеживания обработанных событий и обеспечения того, что каждое событие будет обработано ровно один раз.
- **Транзакционные системы:** В транзакционных системах офсеты могут использоваться для отслеживания транзакций и обеспечения их атомарности.
- **Потоковая аналитика:** Офсеты могут использоваться для отслеживания обработанных данных в системах аналитики в реальном времени.

**Дополнительные сведения:**

- **Сохранение офсетов:** Офсеты сохраняются в Kafka в течении определенного времени (определяется параметром `retention.ms`). Это позволяет восстанавливать состояние потребителя при перезапуске.
- **Управление офсетами:** Потребители могут управлять своими офсетами, устанавливая их вручную или используя автоматические механизмы коммита.
- **Офсеты и группы потребителей:** Офсеты сохраняются в контексте группы потребителей, что позволяет обеспечить справедливое распределение сообщений между потребителями в группе.

# Apache Kafka vs RabbitMQ: Сравнение

Apache Kafka и RabbitMQ - это популярные брокеры сообщений, которые используются для асинхронной передачи сообщений между приложениями. Хотя оба инструмента решают похожие задачи, у них есть значительные различия:

**1. Модель обмена сообщениями:**

- **Kafka:** **Stream-ориентированный** брокер. Он оптимизирован для обработки высокопроизводительных потоков данных в реальном времени. Сообщения сохраняются в топиках (темах), по которым подписчики могут подключаться и получать данные.
- **RabbitMQ:** **Message-ориентированный** брокер. Он поддерживает различные паттерны обмена сообщениями, включая очереди (queues) и обмены (exchanges). Сообщения отправляются в очереди и обрабатываются подписчиками по очереди.

**2. Производительность и масштабируемость:**

- **Kafka:** **Высокопроизводительный** брокер, оптимизированный для обработки больших объемов данных. Он масштабируется горизонтально за счет распределенной архитектуры.
- **RabbitMQ:** **Достаточно производительный** брокер, но менее масштабируемый, чем Kafka. Он масштабируется вертикально за счет добавления ресурсов на один сервер.

**3. Возможности:**

- **Kafka:** **Фокус на потоковой обработке:** Kafka имеет встроенные возможности для потоковой обработки данных, такие как консумы (consumers) и производители (producers).
- **RabbitMQ:** **Широкий набор функций:** RabbitMQ поддерживает более широкий набор функций, включая различные паттерны обмена сообщениями, управление доступом и безопасность.

**4. Использование:**

- **Kafka:** Используется в системах с высокой пропускной способностью, таких как обработка логов, аналитика в реальном времени, стриминговые платформы.
- **RabbitMQ:** Используется в более традиционных системах обмена сообщениями, таких как обработка заказов, системы сообщения о событиях, API интеграции.

**Сводная таблица:**

| Feature             | Kafka                                                                   | RabbitMQ                                                                |
| ------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Модель              | Stream-ориентированный                                                  | Message-ориентированный                                                 |
| Производительность  | Высокая                                                                 | Достаточно высокая                                                      |
| Масштабируемость    | Горизонтальная                                                          | Вертикальная                                                            |
| Возможности         | Потоковая обработка                                                     | Широкий набор функций                                                   |
| Использование       | Логи, аналитика, стриминговые платформы                                 | Обработка заказов, системы сообщений о событиях, API интеграции         |
| Сообщение в очереди | Хранится до удаления                                                    | Удаляется сразу после получения                                         |
| Клиент              | Глупый сервер, умный клиент (обработка сообщений со стороны получателя) | Умный сервер, глупый клиент (обработка сообщения со стороны получателя) |

**Какой брокер выбрать?**

- **Kafka:** Лучший выбор для высокопроизводительных систем, обрабатывающих большие объемы данных в реальном времени.
- **RabbitMQ:** Лучший выбор для более традиционных систем, которые требуют широкого набора функций и гибкости.