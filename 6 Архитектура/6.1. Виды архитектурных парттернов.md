

[[Монолитная архитектура]]

[[Распределенная архитектура]]


### Микросервисная

**Микросервисная архитектура** - это архитектурный стиль, который разбивает приложение на набор небольших, независимых служб (микросервисов), которые взаимодействуют друг с другом через API. Каждый микросервис отвечает за определенную бизнес-функцию и может быть развернут, масштабирован и обновлен независимо от других.

**Ключевые особенности микросервисной архитектуры:**

- **Независимость:** Каждый микросервис разработан и развернут независимо.
- **Маленький размер:** Микросервисы должны быть небольшими и фокусироваться на одной конкретной функции.
- **Автономность:** Микросервисы должны быть автономными и иметь свою собственную базу данных и логику.
- **Слабая связь:** Микросервисы взаимодействуют друг с другом через четко определенные API, избегая прямых зависимостей.
- **Независимое развертывание:** Микросервисы могут быть развернуты и обновлены независимо друг от друга.
- **Технологическая свобода:** Разные микросервисы могут использовать разные технологии.

**Преимущества микросервисной архитектуры:**

- **Масштабируемость:** Можно масштабировать только те микросервисы, которые требуют больше ресурсов.
- **Устойчивость:** Отказ одного микросервиса не повлияет на работу других.
- **Гибкость:** Легко добавлять новые функции и технологии.
- **Независимая разработка:** Разные команды могут работать над разными микросервисами одновременно.
- **Более быстрое время выхода на рынок:** Новые функции можно внедрять быстрее.

**Недостатки микросервисной архитектуры:**

- **Сложность:** Требуется больше усилий для разработки, развертывания и управления микросервисами.
- **Распределенные системы:** Сложнее отлаживать и управлять распределенными системами.
- **Управление зависимостями:** Необходимо тщательно управлять зависимостями между микросервисами.
- **Сеть:** Требуется надежная сеть для взаимодействия между микросервисами.

**Пример использования микросервисной архитектуры:**

- **Интернет-магазин:** Микросервисы могут быть созданы для обработки заказов, управления товарами, обработки платежей, аутентификации пользователей и т.д.

**Примеры популярных технологий для микросервисов:**

- **Docker:** Инструмент для контейнеризации, который позволяет легко развертывать и управлять микросервисами.
- **Kubernetes:** Система оркестрации контейнеров, которая помогает управлять кластерами микросервисов.
- **Spring Boot:** Фреймворк для создания микросервисов на Java.
- **Go:** Язык программирования, который хорошо подходит для разработки микросервисов.
- **Apache Kafka:** Система очередей сообщений, которая позволяет микросервисам общаться друг с другом.

**Микросервисная архитектура становится все более популярной для создания современных, масштабируемых и устойчивых приложений. Она позволяет создавать сложные системы, которые легко развиваются и масштабируются, но требует дополнительных усилий для разработки и управления.**


### Сервис ориентированная архитектура

**Сервис-ориентированная архитектура (SOA)** - это архитектурный стиль, который фокусируется на создании приложения как набора взаимосвязанных сервисов. Сервисы - это независимые модули, которые предоставляют определенные функции и взаимодействуют друг с другом через стандартизированные интерфейсы.

**Ключевые принципы SOA:**

- **Сервисы как модули:** Приложение разделяют на сервисы, каждый из которых отвечает за определенную функцию.
- **Стандартные интерфейсы:** Сервисы взаимодействуют через стандартизированные интерфейсы, такие как SOAP или REST.
- **Слабая связь:** Сервисы слабо связаны друг с другом, что позволяет им быть независимыми.
- **Повторное использование:** Сервисы можно повторно использовать в разных приложениях.
- **Масштабируемость:** Сервисы можно масштабировать независимо друг от друга.

**Преимущества SOA:**

- **Гибкость:** Система становится более гибкой, так как можно легко добавлять или изменять сервисы без изменения всей системы.
- **Масштабируемость:** Сервисы можно масштабировать независимо друг от друга.
- **Повторное использование:** Сервисы можно повторно использовать в разных приложениях.
- **Независимость:** Разные команды могут работать над разными сервисами независимо.
- **Лучшее управление:** Управление сервисами становится более централизованным.

**Недостатки SOA:**

- **Сложность:** SOA может быть более сложной в реализации, чем традиционные архитектуры.
- **Управление зависимостями:** Сложно управлять зависимостями между сервисами.
- **Проблемы с производительностью:** Взаимодействие между сервисами может быть медленным.
- **Необходимость стандартизации:** Требуется стандартизировать интерфейсы и форматы данных.

**Примеры SOA:**

- **Интернет-магазин:** Разные сервисы могут отвечать за обработку заказов, управление товарами, обработку платежей и т. д.
- **Финансовые системы:** Разные сервисы могут отвечать за операции с банковскими счетами, операции с ценными бумагами и т. д.
- **Системы управления ресурсами:** Разные сервисы могут отвечать за управление персоналом, управление оборудованием и т. д.

**SOA - это архитектурный стиль, который подходит для сложных систем, требующих высокой гибкости, масштабируемости и повторного использования. Она позволяет создавать модульные, легко управляемые системы, но требует дополнительных усилий для разработки и управления.**

**Важно отметить, что SOA - это не отдельная технология, а скорее философия разработки, которая может быть реализована с помощью разных технологий и подходов.**
### Монолит

Монолитная архитектура - это архитектурный стиль, где все компоненты приложения объединены в единый код, который развертывается как одно целое. Это классический подход к разработке программного обеспечения, который использовался до появления микросервисов.

**Характеристики монолитной архитектуры:**

- **Единый код:** Все функциональные модули приложения объединены в одном кодовом репозитории.
- **Централизованная база данных:** Обычно используется единая база данных для всех компонентов приложения.
- **Единое развертывание:** Все приложение развертывается как единый пакет.
- **Тесная связь:** Компоненты приложения тесно связаны друг с другом.

**Преимущества монолитной архитектуры:**

- **Простота разработки:** Легко разрабатывать и отлаживать, так как все компоненты находятся в одном месте.
- **Простая отладка:** Отладка проблем проще, так как все компоненты доступны в одном коде.
- **Меньше ресурсов:** Требуется меньше ресурсов для разработки и развертывания.
- **Оптимизация производительности:** Компоненты могут взаимодействовать друг с другом быстрее, так как они находятся в одном процессе.

**Недостатки монолитной архитектуры:**

- **Сложность модификации:** Изменение одного компонента может потребовать перекомпиляции и повторного развертывания всего приложения.
- **Сложность масштабирования:** Невозможно масштабировать отдельные компоненты приложения.
- **Уязвимость:** Ошибка в одном компоненте может нарушить работу всего приложения.
- **Замедленный цикл разработки:** Новые функции могут быть сложными для добавления, так как требуется изменять весь код.
- **Технологическая ограниченность:** Все приложение должно использовать одну технологию.

**Примеры использования монолитной архитектуры:**

- **Простые приложения:** Небольшие веб-сайты, приложения для настольных компьютеров.
- **Старые приложения:** Многие существующие приложения, особенно те, которые были разработаны до появления микросервисов.

**Когда подходит монолитная архитектура:**

- **Простые приложения:** Для небольших приложений с ограниченной функциональностью.
- **Стартапы:** Для быстрой разработки и развертывания продукта.
- **Небольшие команды:** Для небольших команд разработчиков, которые могут легко управлять единым кодом.

**Когда не подходит монолитная архитектура:**

- **Сложные приложения:** Для больших приложений с множеством функциональных модулей.
- **Высокие требования к масштабируемости:** Если приложение должно быть масштабируемым для обработки большого количества запросов.
- **Независимая разработка:** Если требуется независимая работа разных команд над разными частями приложения.

**Монолитная архитектура - это простой и эффективный подход для небольших приложений, но для крупных и сложных систем микросервисная архитектура может быть более подходящим вариантом.**

### Бессервисная

Бессервисная архитектура (Serverless)

**Бессервисная архитектура** - это архитектурный стиль, где разработчики фокусируются исключительно на написании кода для своей бизнес-логики, не задумываясь о управлении серверами, инфраструктурой и масштабированием. Вместо этого они используют “бессерверные” платформы, которые автоматически управляют всеми этими аспектами.

**Ключевые особенности бессервисной архитектуры:**

- **Функции (Functions):** Приложения разбиваются на небольшие, независимые функции, которые выполняются по запросу.
- **Автоматическое масштабирование:** Платформа автоматически масштабирует ресурсы в соответствии с нагрузкой на приложение.
- **Управление ресурсами:** Платформа управляет серверами, базами данных, сетевыми ресурсами и другими инфраструктурными компонентами.
- **Платите только за использование:** Оплата происходит только за фактическое время выполнения функций.
- **Фокус на коде:** Разработчики могут сосредоточиться на создании бизнес-логики, не тратя время на настройку и управление инфраструктурой.

**Примеры бессерверных платформ:**

- **AWS Lambda:** Платформа бессерверных вычислений от Amazon.
- **OpenAI Cloud Functions:** Платформа бессерверных вычислений от Google.
- **Azure Functions:** Платформа бессерверных вычислений от Microsoft.
- **Netlify:** Платформа для размещения веб-приложений с бессерверными функциями.
- **Vercel:** Платформа для размещения веб-приложений с бессерверными функциями.

**Преимущества бессервисной архитектуры:**

- **Снижение затрат:** Оплата только за фактическое использование, что снижает затраты на инфраструктуру.
- **Повышенная масштабируемость:** Автоматическое масштабирование позволяет легко обрабатывать пиковые нагрузки.
- **Упрощение разработки:** Разработчики могут сосредоточиться на написании кода, не беспокоясь об инфраструктуре.
- **Быстрое развертывание:** Функции можно развернуть очень быстро, что ускоряет процесс разработки.
- **Улучшенная надежность:** Платформа управляет надежностью и доступностью функций.

**Недостатки бессервисной архитектуры:**

- **Зависимость от платформы:** Приложение зависит от выбранной бессерверной платформы.
- **Ограничения:** Функции могут иметь ограничение по времени выполнения и использованию ресурсов.
- **Сложности отладки:** Отладка проблем может быть сложной из-за отсутствия прямого доступа к серверам.
- **“Холодный старт”:** Первое выполнение функции может быть медленным, так как ей нужно время для запуска.
- **Безопасность:** Необходимо тщательно управлять безопасностью функций, так как они выполняются в среде, управляемой платформой.

**Когда подходит бессервисная архитектура:**

- **Частые изменения:** Для приложений, которые часто обновляются и меняются.
- **Непредсказуемая нагрузка:** Для приложений, которые испытывают пиковые нагрузки.
- **Небольшие приложения:** Для небольших, автономных функций, таких как обработка событий, интеграции API и т.д.
- **Быстрая разработка:** Для ускорения процесса разработки и развертывания.

**Когда не подходит бессервисная архитектура:**

- **Приложения с высокими требованиями к производительности:** Для приложений, где требуется высокая производительность и низкая задержка.
- **Приложения с длительным временем выполнения:** Для приложений, где функции работают в течение длительного времени.
- **Приложения с строгими требованиями к безопасности:** Для приложений, где требуется полный контроль над безопасностью.

**Бессервисная архитектура - это относительно новый подход к разработке, который быстро набирает популярность. Она предлагает ряд преимуществ, но также имеет свои ограничения. Важно тщательно взвесить преимущества и недостатки бессервисной архитектуры, прежде чем использовать ее для своих проектов.**

https://habr.com/ru/companies/alconost/articles/522662/
### Управляемая событиями архитектура

**Управляемая событиями архитектура (EDA)** - это архитектурный стиль, в котором компоненты системы взаимодействуют друг с другом асинхронно, через передачу событий. Вместо прямого вызова методов, компоненты публикуют и подписываются на события.

**Ключевые принципы EDA:**

- **Асинхронность**: Компоненты взаимодействуют без необходимости синхронного ожидания ответа.
- **Децентрализация**: Отсутствует центральный управляющий компонент, который координирует все операции.
- **Свободная связь**: Компоненты не имеют прямой зависимости друг от друга, взаимодействуя через события.
- **События как источник информации**: События служат единым языком для обмена данными и уведомлений между компонентами.

**Преимущества EDA:**

- **Масштабируемость**: Легко добавлять новые компоненты и масштабировать систему, не затрагивая существующие.
- **Устойчивость**: Система становится более устойчивой к отказам, так как компоненты не зависят друг от друга.
- **Гибкость**: Возможность быстро реагировать на изменения требований, добавляя или модифицируя компоненты без изменения всей системы.
- **Независимость**: Компоненты могут быть разработаны и развернуты независимо друг от друга.
- **Лучшее понимание потока данных**: События предоставляют четкую картину о том, что происходит в системе.

**Архитектурные компоненты EDA:**

- **Источник событий**: Компонент, который генерирует события.
- **Канал событий**: Механизм, обеспечивающий передачу событий от источника к получателям.
- **Обработчик событий**: Компонент, который реагирует на события и выполняет определенные действия.

**Реализации EDA:**

- **Мессенджер**: Используется для публикации и подписки на события (например, RabbitMQ, Kafka).
- **Потоковая обработка**: Обработка событий в реальном времени (например, Apache Flink, Apache Spark Streaming).
- **Реактивное программирование**: Написание кода, реагирующего на изменения данных (например, RxJava, ReactiveX).

**Примеры использования EDA:**

- **Обработка заказов**: Создание заказа, изменение статуса заказа, отмена заказа.
- **Аналитика**: Сбор данных, анализ данных, создание отчетов.
- **Микросервисы**: Взаимодействие между микросервисами.

**Недостатки EDA:**

- **Сложность**: Сложнее реализовать и поддерживать, чем традиционные архитектуры.
- **Отладка**: Сложно отлаживать систему из-за асинхронности и децентрализованности.
- **Согласованность**: Необходимо обеспечивать согласованность данных между компонентами.
**EDA - это мощный инструмент для создания масштабируемых, устойчивых и гибких систем. Она подходит для сложных приложений, где требуется обработка большого количества данных в реальном времени.**
### Представление — контроллер

**MVC (Model-View-Controller)** - это архитектурный шаблон, который разделяет приложение на три основных компонента:

**1. Модель (Model)**:

- Отвечает за хранение и управление данными приложения.
- Не зависит от представления и контроллера.
- Представляет бизнес-логику приложения.
- Предоставляет доступ к данным для контроллера и представления.
- Может уведомлять контроллер о изменениях данных.

**2. Представление (View)**:

- Отвечает за отображение данных пользователю.
- Получает данные от контроллера.
- Не содержит бизнес-логику.
- Обновляется, когда контроллер уведомляет о изменениях в модели.

**3. Контроллер (Controller)**:

- Обеспечивает взаимодействие между моделью и представлением.
- Получает запросы от пользователя (например, нажатия на кнопку).
- Обновляет модель в соответствии с запросом пользователя.
- Выбирает подходящее представление для отображения данных.
- Уведомляет представление о изменениях в модели.

**Преимущества MVC:**

- **Разделение ответственности**: Каждая часть приложения отвечает за свою функцию.
- **Тестируемость**: Каждая часть приложения может быть протестирована независимо.
- **Повторное использование**: Модули могут быть повторно использованы в других проектах.
- **Гибкость**: Легко изменять представление или контроллер без изменения модели.
- **Масштабируемость**: Легко добавлять новые функции, не затрагивая существующие.

**Пример использования MVC:**

- **Веб-приложение**: Модель хранит данные о пользователях и товарах, контроллер обрабатывает запросы от пользователей, а представление отображает информацию о товарах.

**Реализации MVC:**

- **Ruby on Rails**: Веб-фреймворк, использующий MVC.
- **ASP.NET MVC**: Фреймворк для создания веб-приложений.
- **Spring MVC**: Фреймворк для создания веб-приложений на Java.

**Недостатки MVC:**

- **Сложность**: Может быть сложнее для небольших проектов.
- **Дополнительный код**: Требуется больше кода для реализации, чем в других архитектурах.
- **Не всегда оптимально**: Не подходит для всех типов приложений, например, для одностраничных приложений.

**MVC - это проверенный временем архитектурный шаблон, который хорошо подходит для создания веб-приложений и других сложных систем. Он позволяет обеспечить разделение ответственности, улучшить тестируемость и упростить разработку.**

### Клиент — сервер

**Архитектура “Клиент-сервер”** - это архитектурный стиль, где приложение разделено на два основных компонента: **клиент** и **сервер**.

**Клиент**:

- Представляет собой программу, которая запрашивает ресурсы или услуги у сервера.
- Обычно работает на устройствах пользователей, таких как компьютеры, смартфоны, планшеты.
- Отправляет запросы к серверу и получает ответы.
- Отображает информацию, предоставленную сервером, пользователю.

**Сервер**:

- Представляет собой программу, предоставляющую ресурсы или услуги клиентам.
- Обычно работает на мощных серверах или в облачных средах.
- Хранит данные, обрабатывает запросы клиентов и отправляет ответы.
- Обеспечивает доступ к ресурсам для клиентов.

**Как работает архитектура “Клиент-сервер”:**

1. **Клиент отправляет запрос к серверу:** Например, пользователь вводит адрес сайта в браузере, и браузер отправляет запрос к серверу сайта.
2. **Сервер обрабатывает запрос:** Сервер анализирует запрос и выполняет соответствующие операции, например, извлекает данные из базы данных.
3. **Сервер отправляет ответ клиенту:** Ответ может содержать информацию, файлы, или другие данные, запрошенные клиентом.
4. **Клиент получает ответ:** Клиент получает ответ от сервера и отображает его пользователю.

**Примеры архитектуры “Клиент-сервер”:**

- **Веб-сайты:** Браузер (клиент) отправляет запросы к веб-серверу, который обрабатывает их и отправляет HTML-код, изображения и другие файлы.
- **Электронная почта:** Почтовый клиент (клиент) отправляет сообщения на почтовый сервер, который хранит их и доставляет их получателям.
- **Онлайн-игры:** Игровой клиент (клиент) взаимодействует с игровым сервером, который обрабатывает игровые действия и предоставляет информацию о состоянии игры.
- **Базы данных:** Приложения (клиенты) подключаются к серверу баз данных, чтобы получить доступ к данным.

**Преимущества архитектуры “Клиент-сервер”:**

- **Централизованное управление:** Все данные и ресурсы хранятся на сервере, что облегчает управление и обновление.
- **Повышенная безопасность:** Сервер может обеспечить более строгие меры безопасности, чем отдельные клиентские устройства.
- **Масштабируемость:** Сервер может обслуживать множество клиентов одновременно.
- **Экономия ресурсов:** Клиенты могут использовать менее мощные устройства, так как основная обработка происходит на сервере.

**Недостатки архитектуры “Клиент-сервер”:**

- **Зависимость от сервера:** Клиент зависит от работоспособности сервера.
- **Проблемы с производительностью:** При большом количестве клиентов может возникнуть перегрузка сервера.
- **Сложность развертывания:** Требуется специализированное оборудование и программное обеспечение для настройки сервера.

**Архитектура “Клиент-сервер” является широко распространенным и эффективным архитектурным стилем, который применяется в различных приложениях. Она позволяет централизовать данные, повысить безопасность и масштабируемость, но требует внимания к производительности и зависимости от сервера.**

### Каналы и фильтры

Архитектура “Каналы и фильтры” (Pipes and Filters) - это архитектурный шаблон, где обработка данных происходит поэтапно, проходя через серию независимых компонентов, называемых “каналами” и “фильтрами”.

**Каналы (Pipes):**

- Отвечают за передачу данных между фильтрами.
- Действуют как “трубопроводы”, по которым данные перемещаются от одного фильтра к другому.
- Не обрабатывают данные, а только передают их.

**Фильтры (Filters):**

- Выполняют определенную операцию над данными.
- Независимы друг от друга, то есть каждый фильтр работает со своей частью данных.
- Могут быть соединены в цепочки, чтобы выполнить более сложную обработку.

**Как работает архитектура “Каналы и фильтры”:**

1. Данные вводятся в систему через входной канал.
2. Данные проходят через серию фильтров, каждый из которых выполняет свою задачу.
3. Фильтры могут изменять данные, добавлять новые данные или отбрасывать ненужные данные.
4. После обработки данных выводятся через выходной канал.

**Преимущества архитектуры “Каналы и фильтры”:**

- **Модульность:** Каждый фильтр независим и может быть легко заменен или модифицирован без влияния на другие фильтры.
- **Повторное использование:** Фильтры могут быть повторно использованы в других приложениях.
- **Масштабируемость:** Система может быть легко масштабирована путем добавления новых фильтров.
- **Параллелизм:** Фильтры могут выполняться параллельно, что ускоряет обработку данных.
- **Простая отладка:** Проблемы можно легко изолировать и устранять в отдельном фильтре.

**Примеры использования архитектуры “Каналы и фильтры”:**

- **Обработка текстовых файлов:** Фильтры могут быть использованы для очистки текста, перевода, форматирования и т. д.
- **Потоковая обработка данных:** Фильтры могут использоваться для фильтрации, агрегирования и преобразования данных в реальном времени.
- **Обработка сигналов:** Фильтры могут использоваться для обработки аудио, видео и других сигналов.

**Недостатки архитектуры “Каналы и фильтры”:**

- **Сложность управления:** При большом количестве фильтров управление системой может стать сложным.
- **Проблемы с производительностью:** Если данные передаются через множество фильтров, обработка может быть медленной.
- **Неподходящая для сложных зависимостей:** Архитектура не подходит для задач, где фильтры имеют сложные зависимости друг от друга.

**Архитектура “Каналы и фильтры” - это гибкий и модульный подход к обработке данных, который хорошо подходит для задач, где требуется поэтапная обработка данных. Она позволяет легко создавать сложные системы, которые легко масштабируются и модифицируются.**

### Многоярусная (n-tier architecture)

Многоярусная архитектура - это архитектурный стиль, где приложение разделяется на несколько логических слоев (ярусов), каждый из которых отвечает за определенные функции. Эти слои взаимодействуют друг с другом, чтобы обеспечить функционирование приложения.

**Основные ярусы многоярусной архитектуры:**

- **Представление (Presentation Tier):** Ответственен за взаимодействие с пользователем. Обычно включает в себя графический интерфейс (GUI) приложения.
- **Логический ярус (Business Logic Tier):** Включает в себя бизнес-логику приложения. Отвечает за обработку данных, принятие решений и выполнение операций с данными.
- **Ярус данных (Data Tier):** Включает в себя хранилище данных, такое как базы данных, файлы и другие источники данных. Ответственен за сохранение и извлечение данных.

**Дополнительные ярусы:**

В зависимости от сложности приложения могут быть добавлены дополнительные ярусы, например:

- **Ярус безопасности:** Отвечает за аутентификацию и авторизацию пользователей.
- **Ярус интеграции:** Обеспечивает связь с другими системами.
- **Ярус сервисов:** Предоставляет сервисы для других ярусов.

**Преимущества многоярусной архитектуры:**

- **Разделение ответственности:** Каждый ярус отвечает за свою функцию, что делает систему более модульной и управляемой.
- **Масштабируемость:** Отдельные ярусы можно масштабировать независимо друг от друга.
- **Гибкость:** Изменения в одном ярусе не влияют на другие ярусы.
- **Повторное использование:** Ярусы могут быть повторно использованы в других приложениях.

**Недостатки многоярусной архитектуры:**

- **Сложность:** Сложнее разработать и отладить по сравнению с одноярусными приложениями.
- **Сетевые задержки:** Взаимодействие между ярусами может вызывать сетевые задержки.
- **Управление зависимостями:** Сложно управлять зависимостями между ярусами.

**Примеры многоярусной архитектуры:**

- **Веб-приложение:** Представление - веб-браузер, логический ярус - сервер приложений, ярус данных - база данных.
- **Мобильное приложение:** Представление - мобильное устройство, логический ярус - облачный сервер, ярус данных - база данных.
- **Корпоративная система:** Представление - клиентские приложения, логический ярус - сервер приложений, ярус данных - база данных, ярус безопасности - сервер аутентификации.

**Многоярусная архитектура - это эффективный подход для разработки сложных систем. Она позволяет разделить приложение на модули, повысить масштабируемость, гибкость и повторное использование. Однако, необходимо учитывать сложность разработки и управления многоярусными системами.**
### Многоуровневая