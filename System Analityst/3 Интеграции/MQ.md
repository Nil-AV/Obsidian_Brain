# Apache Kafka

Apache Kafka - это платформа для потоковой обработки данных с открытым исходным кодом, которая позволяет создавать высокопроизводительные, масштабируемые и отказоустойчивые системы для передачи и обработки событий в реальном времени.

**Основные понятия:**

- **Брокер (Broker):** Сервер, который хранит и обрабатывает сообщения. В кластере Kafka может быть несколько брокеров, которые работают вместе, обеспечивая отказоустойчивость и масштабируемость.
- **Тема (Topic):** Категория или тип сообщения, который передается по кафковской системе. Например, “пользовательские события”, “заказы”, “сенсорные данные”.
- **Сообщение (Message):** Фактическая единица данных, которая передается в Kafka. Сообщение содержит полезную нагрузку (данные) и метаданные, такие как время отправки, ключ и т.д.
- **Продуцент (Producer):** Приложение, которое отправляет сообщения в Kafka.
- **Потребитель (Consumer):** Приложение, которое получает и обрабатывает сообщения из Kafka.
- **Разделы (Partitions):** Тема разделяется на секции (разделы) для распределения данных и повышения параллелизма при работе с сообщениями.
- **Офсет (Offset):** Уникальный номер, который идентифицирует конкретное сообщение в определенном разделе.
- **Группа потребителей (Consumer Group):** Группа потребителей, которые совместно потребляют сообщения из определенной темы.
- **Зоокепер (ZooKeeper):** Сервис, который используется для управления кластером Kafka. Он хранит метаданные о брокерах, темах и группах потребителей.

## Partitions


Разделы (Partitions) - это ключевой элемент архитектуры Apache Kafka, который позволяет разбить тему на логические секции для повышения производительности, масштабируемости и отказоустойчивости.

**Как работают разделы:**

- **Разбиение данных:** Каждая тема делится на несколько разделов. Сообщения, отправленные в определенную тему, распределяются по разделам на основе ключа сообщения (если он задан) или по алгоритму Round Robin (по кругу) в случае его отсутствия.
- **Независимое хранение:** Каждый раздел хранится на отдельном брокере в кластере Kafka. Это означает, что данные в каждом разделе доступны независимо от других разделов.
- **Параллелизм:** Разделы позволяют производителям и потребителям работать параллельно. Несколько производителей могут отправлять сообщения в один раздел, а несколько потребителей могут одновременно читать из разных разделов одной и той же темы.

**Зачем нужны разделы:**

- **Повышение производительности:** Разделы позволяют Kafka распределять нагрузку по нескольким брокерам, что увеличивает пропускную способность и скорость обработки сообщений.
- **Масштабируемость:** Разделы позволяют легко добавлять новые брокеры в кластер Kafka, без изменения структуры темы или перенастройки приложений.
- **Отказоустойчивость:** Если брокер с данным разделом выходит из строя, то сообщения в нем остаются доступными на других брокерах, которые хранят реплики этого раздела.
- **Управление данными:** Разделы позволяют управлять доступом к данным на уровне раздела. Например, можно настроить разделы для разных групп потребителей, чтобы обеспечить изоляцию данных.

**Примеры использования:**

- **Логгирование событий:** Если у вас есть много серверов, которые отправляют логи, можно использовать разделы для разделения логов от разных серверов на отдельные разделы, чтобы упростить обработку и анализ данных.
- **Транзакции:** Если вы используете Kafka для обработки транзакций, то разделы могут быть использованы для создания транзакционных тем, где все сообщения в одном разделе обрабатываются в одном атомарном блоке.
- **Потоковая аналитика:** Если вы используете Kafka для аналитики данных в реальном времени, то разделы могут быть использованы для разделения данных на отдельные потоки для параллельной обработки.

**Выбор количества разделов:**

Количество разделов в теме - это важный параметр, который влияет на производительность и масштабируемость. Количество разделов должно быть оптимальным для конкретной задачи и конфигурации кластера Kafka.

**Рекомендации:**

- Количество разделов должно быть больше, чем количество брокеров в кластере, чтобы обеспечить параллелизм.
- Количество разделов должно быть кратным количеству ядер процессора на каждом брокере, чтобы оптимизировать производительность.
- Количество разделов должно быть достаточным для обеспечения достаточной отказоустойчивости и масштабируемости.

**Основные преимущества использования Kafka:**

- **Высокая производительность:** Kafka может обрабатывать миллионы сообщений в секунду.
- **Масштабируемость:** Kafka легко масштабируется за счет добавления новых брокеров.
- **Отказоустойчивость:** Kafka обеспечивает дублирование данных и отказоустойчивость благодаря репликациям сообщений.
- **Потоковая обработка данных:** Kafka позволяет обрабатывать данные в реальном времени, не дожидаясь их сбора.
- **Разные варианты использования:** Kafka может использоваться для широкого спектра задач, от логгинга и мониторинга до обработки транзакций и потоковой аналитики.

**Примеры использования:**

- **Логгирование:** Запись событий, ошибок и аудита в реальном времени.
- **Мониторинг:** Сбор и анализ данных с датчиков, сервисов и систем.
- **Обработка транзакций:** Обеспечение доставки сообщений в системах онлайн-платежей, бронирования и т.д.
- **Потоковая аналитика:** Анализ данных в реальном времени для выявления тенденций и принятия решений.
- **Системы обмена сообщениями:** Создание децентрализованных систем обмена сообщениями, где приложения могут общаться друг с другом асинхронно.


## Офсет (Offset)
- это уникальный идентификатор, который используется для отслеживания позиции каждого сообщения в определенном разделе темы Kafka. Представьте себе раздел как ленту, где каждое сообщение имеет свой порядковый номер, который и называется офсетом.

**Как работает офсет:**

- **Уникальная идентификация:** Каждый офсет уникален в пределах конкретного раздела. Это позволяет однозначно определять каждое сообщение.
- **Порядковый номер:** Офсеты присваиваются сообщениям в порядке их поступления в раздел. Первое сообщение получает офсет 0, второе - 1, и так далее.
- **Управление позицией:** Потребители используют офсеты, чтобы отслеживать, какие сообщения они уже обработали и какие ещё нужно обработать.
- **Перемещение по ленте:** Офсеты позволяют потребителям “перематывать” ленту сообщений:
    - **Переход к определенному офсету:** Потребитель может получить доступ к определенному сообщению, указав его офсет.
    - **Переход к последнему офсету:** Потребитель может начать обработку с последнего сообщения, запросив офсет, равный количеству сообщений в разделе.

**Зачем нужны офсеты:**

- **Гарантия доставки:** Офсеты гарантируют, что каждое сообщение в разделе будет обработано ровно один раз.
- **Переработка сообщений:** Офсеты позволяют потребителям перезапускать обработку сообщений с определенного офсета, если в процессе произошла ошибка.
- **Сохранение состояния:** Офсеты могут использоваться для сохранения состояния потребителя. Например, потребитель может запомнить офсет последнего обработанного сообщения и возобновить обработку с этого места при перезапуске.
- **Управление данными:** Офсеты позволяют управлять доступом к данным в разделе на уровне отдельных сообщений.

**Примеры использования:**

- **Обработка потока событий:** Если у вас есть поток событий, то вы можете использовать офсеты для отслеживания обработанных событий и обеспечения того, что каждое событие будет обработано ровно один раз.
- **Транзакционные системы:** В транзакционных системах офсеты могут использоваться для отслеживания транзакций и обеспечения их атомарности.
- **Потоковая аналитика:** Офсеты могут использоваться для отслеживания обработанных данных в системах аналитики в реальном времени.

**Дополнительные сведения:**

- **Сохранение офсетов:** Офсеты сохраняются в Kafka в течении определенного времени (определяется параметром `retention.ms`). Это позволяет восстанавливать состояние потребителя при перезапуске.
- **Управление офсетами:** Потребители могут управлять своими офсетами, устанавливая их вручную или используя автоматические механизмы коммита.
- **Офсеты и группы потребителей:** Офсеты сохраняются в контексте группы потребителей, что позволяет обеспечить справедливое распределение сообщений между потребителями в группе.